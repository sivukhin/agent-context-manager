#!/usr/bin/env bun

import { config } from 'dotenv'
import path from 'path';

config({ path: path.join(import.meta.dirname, '.env'), quiet: true })

import chalk from 'chalk';
import { unified } from 'unified'
import remarkParse from 'remark-parse'
import remarkMdx from 'remark-mdx'
import remarkStringify from 'remark-stringify'
import remarkFrontmatter from "remark-frontmatter"
import * as yaml from "js-yaml";
import { Node, Nodes } from 'mdast';

import * as fs from "fs";

import { ComponentArgs, ComponentAttributes, ComponentOutput, ComponentData, ContextSession, deep } from './types.js';
import { InputComponent } from './components/input.js';
import { OutputComponent } from './components/output.js';
import { ShellComponent } from './components/shell.js';
import { FileComponent } from './components/file.js';
import { TextComponent } from './components/text.js';
import { ReviewComponent } from './components/review.js';
import { ResearchComponent } from './components/research.js';
import { CodeComponent } from './components/code.js';
import { OutlineComponent } from './components/outline.js';
import { ReadmeComponent } from './components/readme.js';
import { LlmComponent } from './components/llm.js';
import { LinkComponent } from './components/link.js';
import { GitHubIssueComponent } from './components/gh_issue.js';
import { GitHubPrComponent } from './components/gh_pr.js';

import { program } from "commander";
import { connectDb, Db, hashComponent } from './db.js';
import { tokens } from './model.js';
import { graph, Graph } from './graph.js';

interface Context {
    frontmatter: { [K: string]: any };
    roots: string[];
    nodes: Collection<ContextNode>;
}

type ContextNode =
    { type: 'text', id: string, content: string } |
    { type: 'context', id: string, refs: string[], name: string, attributes: ComponentAttributes, children: string[] };

function printNode(node: ContextNode, content?: string): string {
    if (node.type === 'context') {
        const attributes = Object.entries(node.attributes).map(e => `${e[0]}=${JSON.stringify(e[1])}`).join(" ");
        return `<${node.name} ${attributes}>\n${content}\n</${node.name}>`;
    } else {
        return node.content;
    }
}



const processor = unified()
    .use(remarkParse)
    .use(remarkMdx)
    .use(remarkFrontmatter, ['yaml', 'toml'])
    .use(remarkStringify);

type ContextState = {
    last: number;
}

interface Collection<T> {
    add(key: string, value: T): void;
    get(key: string): T | null;
    mustGet(key: string): T;
    entries(): [string, T][];
}

function collection<T>(): Collection<T> {
    const values = new Map();
    return {
        add(key: string, value: T) {
            if (values.has(key)) {
                throw new Error(`duplicate key: ${key}`);
            }
            values.set(key, value);
        },
        get(key: string) {
            return values.get(key);
        },
        mustGet(key: string) {
            const value = values.get(key);
            if (value == null) {
                throw new Error(`no node with key ${key} `);
            }
            return value;
        },
        entries() {
            return Array.from(values.entries());
        },
    }
}

function createContextTreeFromAst(ctx: ContextState, ast: Node): [string, Collection<ContextNode>] {
    if (ast.type == 'mdxJsxFlowElement') {
        let attributes: { [K: string]: any } = {};
        let id = null;
        let refs = [];
        for (const attribute of (ast as any).attributes) {
            if (attribute.type == 'mdxJsxAttribute') {
                let value = undefined;
                if (typeof attribute.value == "string") {
                    value = attribute.value;
                } else if (attribute.value != null) {
                    value = eval(attribute.value.value);
                } else {
                    value = true;
                }
                if (attribute.name == 'id' && value !== undefined) {
                    id = value;
                } else if (value !== undefined) {
                    if (attribute.name == "ref") {
                        refs.push(value);
                    }
                    attributes[attribute.name] = value;
                }
            } else {
                throw new Error(`unsupported JSX attribute: ${attribute} `);
            }
        }
        ctx.last += 1;
        if (id == null) {
            id = `${(ast as any).name}#${ctx.last}`;
        }
        const aggregated = collection<ContextNode>();
        const childrenIds: string[] = [];
        for (const child of ((ast as any).children as any[])) {
            const childContext = createContextTreeFromAst(ctx, child);
            childrenIds.push(childContext[0]);
            for (const childEntry of childContext[1].entries()) {
                aggregated.add(childEntry[0], childEntry[1]);
            }
        }

        const context: ContextNode = {
            type: 'context',
            id,
            refs,
            name: (ast as any).name,
            attributes: attributes,
            children: childrenIds,
        };
        aggregated.add(id, context);
        return [id, aggregated]
    } else {
        ctx.last += 1;
        const id = `#${ctx.last}`;
        const context: ContextNode = {
            type: 'text',
            id,
            content: processor.stringify(ast as any)
        };
        const aggregated = collection<ContextNode>();
        aggregated.add(id, context);
        return [id, aggregated];
    }
}

function createContextTreeFromString(content: string): Context {
    const ast = processor.parse(content);
    const ctx = { last: 0 };
    let frontmatter = {};
    let children = ast.children;
    if (children[0].type == 'yaml') {
        frontmatter = yaml.load(children[0].value) as any;
        children = children.slice(1);
    }
    const roots = [];
    const aggregated = collection<ContextNode>();
    for (const child of children) {
        const [root, nodes] = createContextTreeFromAst(ctx, child);
        roots.push(root);
        for (const [key, node] of nodes.entries()) {
            aggregated.add(key, node);
        }
    }
    return { roots, nodes: aggregated, frontmatter }
}

interface Component {
    executor: (args: ComponentArgs) => Promise<ComponentOutput>,
    tags: string[];
}

interface NodeSelector {
    id: string;
    side: "input" | "output"
}

interface AgentContextManagerOpts {
    cwd: string;
    selector?: NodeSelector;
    registry: { [K: string]: Component }
}

function intersects(a: string[], b: string[]): boolean {
    const as = new Set(a);
    for (const be of b) {
        if (as.has(be)) {
            return true;
        }
    }
    return false;
}


function session(db: Db, opts: AgentContextManagerOpts): ContextSession {
    const byHash = new Map<string, ComponentOutput>();
    const inputById = new Map<string, string>();
    const outputById = new Map<string, ComponentOutput>();
    return {
        db,
        async getInputById(id: string): Promise<string | null> {
            return inputById.get(id) ?? null;
        },
        async getOutputById(id: string): Promise<ComponentOutput | null> {
            return outputById.get(id) ?? null;
        },
        async getComponentByData(data: ComponentData): Promise<ComponentOutput | null> {
            const component = opts.registry[data.component];
            if (component.tags.includes("nocache")) {
                return null;
            }
            const hash = hashComponent(data);
            let value = byHash.get(hash);
            if (value != null) {
                return value;
            }
            return await db.getComponent(data);
        },
        async setComponent(data: ComponentData, output: ComponentOutput): Promise<void> {
            byHash.set(hashComponent(data), output);
            inputById.set(data.id, data.content);
            outputById.set(data.id, output);
            if (data.component == '') {
                return;
            }
            const component = opts.registry[data.component];
            if (component.tags.includes("nocache")) {
                return;
            }
            await db.setComponent(data, output);
        }
    };
}

function preview(text: string): string {
    let result = text.replaceAll('\n', '\\n');
    if (result.length < 80) {
        return result;
    }
    return result.substring(0, 64) + '...';
}

function buildContextGraph(context: Context): Graph {
    const g = graph();
    for (const [key, value] of context.nodes.entries()) {
        g.addNode(key);
        if (value.type == 'context') {
            for (const ref of value.refs) {
                g.addEdge(key, ref);
            }
            for (const child of value.children) {
                g.addEdge(key, child);
            }
        }
    }
    return g;
}

async function exec(
    session: ContextSession,
    opts: AgentContextManagerOpts,
    context: Context,
    nodes: string[],
    filtered: Set<string>,
    localOnly: boolean,
): Promise<boolean> {
    const stacks = new Map<string, ContextNode[]>();

    const reversed = [...nodes];
    reversed.reverse();

    for (const nodeId of reversed) {
        const node = context.nodes.mustGet(nodeId);
        stacks.set(nodeId, [...(stacks.get(nodeId) || []), node]);
        let current = stacks.get(nodeId)!;
        if (node.type == 'context') {
            for (const childId of node.children) {
                if (!stacks.has(childId)) {
                    stacks.set(childId, []);
                }
                stacks.set(childId, current);
            }
        }
    }

    const stack: [ContextNode, number][] = [];
    for (const nodeId of nodes) {
        if (!filtered.has(nodeId)) {
            continue;
        }
        const node = context.nodes.mustGet(nodeId);
        switch (node.type) {
            case 'text':
                session.setComponent({ id: node.id, component: '', attributes: {}, content: node.content }, { content: node.content })
                break;
            case 'context':
                if (!(node.name in opts.registry)) {
                    throw new Error(`unexpected component ${node.name} `);
                }
                const component = opts.registry[node.name]!;
                const now = performance.now();

                if (!localOnly) {
                    const expectedStack = stacks.get(node.id)!;
                    while (stack.length > 0) {
                        const l = stack.length - 1;
                        if (stack[l][0].id != expectedStack[l]?.id) {
                            stack.pop();
                        } else {
                            break;
                        }
                    }
                    while (stack.length != expectedStack.length) {
                        const next = expectedStack[stack.length];
                        if (next.type == 'context') {
                            if (filtered.has(next.id)) {
                                console.info(' '.repeat(stack.length) + chalk.green(`+ start `) + chalk.bold(`${next.name} [${next.id}]`));
                            } else {
                                console.info(' '.repeat(stack.length) + chalk.gray(`/ scope `) + chalk.bold(`${next.name} [${next.id}]`));
                            }
                        }
                        stack.push([next, now])
                    }
                }


                let childrenContent = "";
                const childrenAttributes: ComponentAttributes = {};
                for (const c of node.children) {
                    const result = await session.getOutputById(c);
                    childrenContent += result?.content + "\n";
                    childrenAttributes[c] = result?.attributes;
                }
                if (!localOnly) {
                    if (component.tags.includes('llm')) {
                        const contentTokens = tokens(node.attributes['model'], childrenContent);
                        console.info(' '.repeat(stack.length) + chalk.bold(`  ‚¨ê [${contentTokens}] `) + chalk.gray(chalk.italic(preview(childrenContent))));
                    } else {
                        console.info(' '.repeat(stack.length) + chalk.bold(`  ‚¨ê `) + chalk.gray(chalk.italic(preview(childrenContent))));
                    }
                }

                const componentData = {
                    id: node.id,
                    component: node.name,
                    attributes: node.attributes,
                    content: childrenContent
                };

                let componentResult = await session.getComponentByData(componentData);
                if (componentResult == null) {
                    if (localOnly && !component.tags.includes('local')) {
                        return false;
                    }
                    const startExecutor = performance.now();
                    componentResult = await component.executor({
                        session,
                        attributes: node.attributes,
                        content: { content: childrenContent, attributes: childrenAttributes },
                        cwd: opts.cwd
                    });
                    if (!localOnly) {
                        const elapsedExecutor = performance.now() - startExecutor;
                        console.info(' '.repeat(stack.length) + chalk.green(`- stop  `) + chalk.bold(`${node.name} [${node.id}]`) + chalk.gray(` ${(elapsedExecutor / 1000).toFixed(2)}s`));
                    }
                } else if (componentResult != null && !localOnly) {
                    console.info(' '.repeat(stack.length) + chalk.blueBright(`‚Ä¢ reuse `) + chalk.bold(`${node.name} [${node.id}]`) + ' ' + hashComponent(componentData).substring(0, 8))
                }
                if (!localOnly) {
                    if (component.tags.includes('llm')) {
                        const contentTokens = tokens(node.attributes['model'], componentResult.content);
                        console.info(' '.repeat(stack.length) + chalk.bold(`  ‚§∑ [${contentTokens}] `) + chalk.italic(preview(componentResult.content)));
                    } else {
                        console.info(' '.repeat(stack.length) + chalk.bold(`  ‚§∑ `) + chalk.gray(chalk.italic(preview(componentResult.content))));
                    }
                }
                if (node.attributes["output"] != null) {
                    if (localOnly) {
                        if ((await session.getOutputById(node.id))?.content != componentResult.content) {
                            return false;
                        }
                    } else {
                        fs.writeFileSync(path.join(opts.cwd, node.attributes["output"]), componentResult.content);
                        console.info(' '.repeat(stack.length) + chalk.bold(`  üíæ `) + chalk.gray(node.attributes["output"]));
                    }
                }
                await session.setComponent(componentData, componentResult);
                break;
        }
    }
    return true;
}

async function execString(opts: AgentContextManagerOpts, code: string): Promise<string> {
    const context = createContextTreeFromString(code);
    const contextGraph = buildContextGraph(context);

    const nodes = contextGraph.nodesTopo();

    let filtered = new Set(nodes);
    if (opts.selector != null) {
        filtered = contextGraph.reachable(opts.selector.id);
        if (opts.selector.side == 'input') {
            filtered.delete(opts.selector.id);
        }
    }

    const stacks = new Map<string, ContextNode[]>();

    const reversed = [...nodes];
    reversed.reverse();

    for (const nodeId of reversed) {
        const node = context.nodes.mustGet(nodeId);
        stacks.set(nodeId, [...(stacks.get(nodeId) || []), node]);
        let current = stacks.get(nodeId)!;
        if (node.type == 'context') {
            for (const childId of node.children) {
                if (!stacks.has(childId)) {
                    stacks.set(childId, []);
                }
                stacks.set(childId, current);
            }
        }
    }

    const dbPath = path.join(import.meta.dirname, '.agents', context.frontmatter['name']);
    const db = await connectDb(dbPath);
    const current = session(db, opts);

    let attempt = 1;
    while (true) {
        console.info(chalk.bgGray(`attempt#${attempt}`))
        attempt += 1;

        await exec(current, opts, context, nodes, filtered, false);
        let failed = false;
        for (const node of context.roots) {
            const attrs = (await current.getOutputById(node))?.attributes;
            failed ||= deep(attrs, "failed").filter((x: any) => x == true).length > 0;
        }
        if (!failed) {
            break;
        }
        if (failed && await exec(current, opts, context, nodes, filtered, true)) {
            console.info(chalk.bgRed(`failure without changes`))
            break;
        }
    }

    let final = [];
    if (opts.selector == null) {
        final = context.roots;
    }
    if (opts.selector == null) {
        const result = [];
        for (const root of context.roots) {
            result.push((await current.getOutputById(root))?.content);
        }
        return result.join('\n');
    }

    const node = context.nodes.mustGet(opts.selector.id);
    if (opts.selector.side == "output") {
        final = [opts.selector.id];
    } else {
        final = node.type == 'context' ? node.children : [];
    }

    const result = [];
    for (const root of final) {
        result.push((await current.getOutputById(root))?.content);
    }
    return result.join('\n');
}

const registry = {
    'Input': { executor: InputComponent, tags: ['local', 'nocache'] },
    'Output': { executor: OutputComponent, tags: ['local', 'nocache'] },

    'File': { executor: FileComponent, tags: ['local', 'nocache'] },
    'Text': { executor: TextComponent, tags: ['local', 'nocache'] },

    'Shell': { executor: ShellComponent, tags: ['local', 'nocache'] },
    'Link': { executor: LinkComponent, tags: ['network'] },
    'GitHubIssue': { executor: GitHubIssueComponent, tags: ['network'] },
    'GitHubPr': { executor: GitHubPrComponent, tags: ['network'] },

    'Review': { executor: ReviewComponent, tags: ['llm'] },
    'Research': { executor: ResearchComponent, tags: ['llm'] },
    'Code': { executor: CodeComponent, tags: ['llm'] },
    'Outline': { executor: OutlineComponent, tags: ['llm'] },
    'Readme': { executor: ReadmeComponent, tags: ['llm'] },
    'Llm': { executor: LlmComponent, tags: ['llm'] },
};

program.command('run <filepath>').option('-n, --node <node>').action(async (filepath, options) => {
    const content = fs.readFileSync(path.join(process.cwd(), filepath)).toString("utf-8");
    let selector: NodeSelector | undefined = undefined;
    if (options.node != null) {
        selector = {
            id: options.node.split(':')[0],
            side: options.node.split(':')[1] == "input" ? "input" : "output",
        };
    }
    const opts = {
        cwd: process.cwd(),
        registry,
        selector,
    };
    const result = await execString(opts, content);
    console.info(result);
});

program.parse();