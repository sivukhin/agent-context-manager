#!/usr/bin/env bun

import { config } from 'dotenv'
import path from 'path';

config({ path: path.join(import.meta.dirname, '.env'), quiet: true })

import { unified } from 'unified'
import remarkParse from 'remark-parse'
import remarkMdx from 'remark-mdx'
import remarkStringify from 'remark-stringify'
import remarkFrontmatter from "remark-frontmatter"
import * as yaml from "js-yaml";
import { Node } from 'mdast';

import * as fs from "fs";

import { ComponentArgs, ComponentAttributes } from './types.js';
import { ShellComponent } from './components/shell.js';
import { FileComponent } from './components/file.js';
import { ReviewComponent } from './components/review.js';
import { ResearchComponent } from './components/research.js';
import { CodeComponent } from './components/code.js';
import { OutlineComponent } from './components/outline.js';
import { ReadmeComponent } from './components/readme.js';
import { LinkComponent } from './components/link.js';
import { OutputComponent } from './components/output.js';
import { GitHubIssueComponent } from './components/gh_issue.js';
import { GitHubPrComponent } from './components/gh_pr.js';

import { program } from "commander";
import { connectDb, Db } from './db.js';

interface Context {
    frontmatter: { [K: string]: any };
    tree: ContextTree[];
}

type ContextTree =
    { type: 'text', content: string } |
    { type: 'context', id: string, name: string, attributes: ComponentAttributes, children: ContextTree[] };

const processor = unified()
    .use(remarkParse)
    .use(remarkMdx)
    .use(remarkFrontmatter, ['yaml', 'toml'])
    .use(remarkStringify);

type ContextState = {
    last: number;
}

function createContextTreeFromAst(ctx: ContextState, ast: Node): ContextTree[] {
    if (ast.type == 'mdxJsxFlowElement') {
        let attributes: { [K: string]: any } = {};
        for (const attribute of (ast as any).attributes) {
            if (attribute.type == 'mdxJsxAttribute') {
                if (typeof attribute.value == "string") {
                    attributes[attribute.name] = attribute.value;
                } else if (attribute.value != null) {
                    attributes[attribute.name] = eval(attribute.value.value);
                }
            } else {
                throw new Error(`unsupported JSX attribute: ${attribute}`);
            }
        }
        ctx.last += 1;
        return [{
            type: 'context',
            id: `${(ast as any).name}#${ctx.last}`,
            name: (ast as any).name,
            attributes: attributes,
            children: ((ast as any).children as any[]).flatMap(c => createContextTreeFromAst(ctx, c))
        }];
    } else {
        return [{
            type: 'text',
            content: processor.stringify(ast as any)
        }];
    }
}

function createContextTreeFromString(content: string): Context {
    const ast = processor.parse(content);
    const ctx = { last: 0 };
    let frontmatter = {};
    let children = ast.children;
    if (children[0].type == 'yaml') {
        frontmatter = yaml.load(children[0].value) as any;
        children = children.slice(1);
    }
    const tree = children.flatMap(c => createContextTreeFromAst(ctx, c));
    return { tree, frontmatter }
}

interface Component {
    executor: (args: ComponentArgs) => Promise<string>,
    tags: string[];
}

interface AgentContextManagerOpts {
    cwd: string;
    skip: string[];
    registry: { [K: string]: Component }
}

function intersects(a: string[], b: string[]): boolean {
    const as = new Set(a);
    for (const be of b) {
        if (as.has(be)) {
            return true;
        }
    }
    return false;
}

async function execContext(db: Db, opts: AgentContextManagerOpts, context: ContextTree[]): Promise<string> {
    const result = [];
    for (const element of context) {
        switch (element.type) {
            case 'text':
                result.push(element.content);
                break;
            case 'context':
                const content = await execContext(db, opts, element.children);
                if (!(element.name in opts.registry)) {
                    throw new Error(`unexpected component ${element.name}`);
                }

                const component = opts.registry[element.name]!;
                if (intersects(opts.skip, component.tags)) {
                    result.push(`<${element.name} ${Object.entries(element.attributes).map(e => `${e[0]}=${JSON.stringify(e[1])}`).join(" ")}>
${content}
</${element.name}>
                `);
                    break;
                }

                const componentData = { id: element.id, component: element.name, attributes: element.attributes, content: content };
                let componentResult = await db.getComponent(componentData);
                if (componentResult != null && !component.tags.includes('nocache')) {
                    result.push(componentResult);
                    break;
                }

                componentResult = await component.executor({
                    db: db,
                    attributes: element.attributes,
                    content: content,
                    cwd: opts.cwd
                })
                await db.setComponent(componentData, componentResult);

                result.push(componentResult);
                break;
        }
    }
    return result.join('\n');
}

async function showContext(db: Db, opts: AgentContextManagerOpts, context: ContextTree[]): Promise<string> {
    const result = [];
    for (const element of context) {
        switch (element.type) {
            case 'text':
                result.push(element.content);
                break;
            case 'context':
                const content = await showContext(db, opts, element.children);
                if (!(element.name in opts.registry)) {
                    throw new Error(`unexpected component ${element.name}`);
                }

                const component = opts.registry[element.name]!;
                if (intersects(opts.skip, component.tags)) {
                    result.push(`<${element.name} ${Object.entries(element.attributes).map(e => `${e[0]}=${JSON.stringify(e[1])}`).join(" ")}>
${content}
</${element.name}>
                `);
                    break;
                }

                const componentData = { id: element.id, component: element.name, attributes: element.attributes, content: content };
                let componentResult = await db.getComponent(componentData);
                if (componentResult != null && !intersects(opts.skip, component.tags)) {
                    result.push(componentResult);
                    break;
                }
                result.push(`<${element.name} ${Object.entries(element.attributes).map(e => `${e[0]}=${JSON.stringify(e[1])}`).join(" ")}>
${content}
</${element.name}>
                `)
                break;
        }
    }
    return result.join('\n');
}

async function execString(opts: AgentContextManagerOpts, content: string): Promise<string> {
    const context = createContextTreeFromString(content);
    const dbPath = path.join(import.meta.dirname, '.agents', context.frontmatter['name']);
    const db = await connectDb(dbPath);
    return await execContext(db, opts, context.tree);
}

async function showString(opts: AgentContextManagerOpts, content: string): Promise<string> {
    const context = createContextTreeFromString(content);
    const dbPath = path.join(import.meta.dirname, '.agents', context.frontmatter['name']);
    const db = await connectDb(dbPath);
    return await showContext(db, opts, context.tree);
}

const registry = {
    'Shell': { executor: ShellComponent, tags: ['local', 'nocache'] },
    'File': { executor: FileComponent, tags: ['local', 'nocache'] },
    'Output': { executor: OutputComponent, tags: ['local', 'nocache'] },

    'Link': { executor: LinkComponent, tags: ['network', 'nocache'] },
    'GitHubIssue': { executor: GitHubIssueComponent, tags: ['network', 'nocache'] },
    'GitHubPr': { executor: GitHubPrComponent, tags: ['network', 'nocache'] },

    'Review': { executor: ReviewComponent, tags: ['llm'] },
    'Research': { executor: ResearchComponent, tags: ['llm'] },
    'Code': { executor: CodeComponent, tags: ['llm'] },
    'Outline': { executor: OutlineComponent, tags: ['llm'] },
    'Readme': { executor: ReadmeComponent, tags: ['llm'] },
};

program.command('run <filepath>').option('-s, --skip <tags>').action(async (filepath, options) => {
    const content = fs.readFileSync(path.join(process.cwd(), filepath)).toString("utf-8");
    const result = await execString({ cwd: process.cwd(), registry, skip: options.skip?.split(',') ?? [] }, content);
    console.info(result);
});

program.command('show <filepath>').option('-s, --skip <tags>').action(async (filepath, options) => {
    const content = fs.readFileSync(path.join(process.cwd(), filepath)).toString("utf-8");
    const result = await showString({ cwd: process.cwd(), registry, skip: options.skip?.split(',') ?? [] }, content);
    console.info(result);
});

program.parse();